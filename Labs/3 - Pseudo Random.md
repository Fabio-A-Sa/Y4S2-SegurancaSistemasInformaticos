# Pseudo Random Number Generation Lab

Random number generation is crucial in security software, especially for encryption keys. This lab focuses on secure methods, addressing common mistakes and introducing special device files like `/dev/random` and `/dev/urandom`.

## Task 1: Generate Encryption Key in a Wrong Way

With the provided code, we found that the `srand(time(NULL))` instruction seed the pseudo-random number generator with the current time, ensuring that each time the program runs, a different sequence of random numbers is generated.

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define KEYSIZE 16

void main() {
    int i;
    char key[KEYSIZE];
    printf("%lld\n", (long long) time(NULL));
    srand (time(NULL));
    for (i = 0; i< KEYSIZE; i++) {
        key[i] = rand()%256;
        printf("%.2x", (unsigned char)key[i]);
    }
    printf("\n");
}
```

However, if the previous instruction is commented out, the random number generator remains unseeded. Consequently, the sequence of random numbers generated by `rand()` remains constant across multiple executions of the program.

Then, the crucial role of `srand()` and `time()` introducing randomness and variability into programs that depend on pseudo-random number generation.

## Task 2: Guessing the Key

According to the text, the key of the file was generated with a code similar to the previous one between `2018-04-17 21:08:49` and `2018-04-17 23:08:49`. The first step will therefore be to extract all the seeds from these values, using the `date` command to print out the number of seconds between a specified time and the Epoch:

```bash
date -d "2018-04-17 21:08:49" +%s # 1524013729
date -d "2018-04-17 23:08:49" +%s # 1524020929
```

And then generate all possible keys within that range:

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define KEYSIZE 16

void main() {

    int i;
    char key[KEYSIZE];

    for (time_t t = 1524013729 ; t < 1524020929 ; t++) {

        srand(t);

        for (i = 0 ; i < KEYSIZE ; i++) {
            key[i] = rand() % 256;
            printf("%.2x", (unsigned char) key[i]);
        }
        printf("\n");
    }
}
```

We store everything in a file for easier manipulation:

```bash
$ gcc -o task2.c task2
$ ./task2 > keys.txt
```

O enunciado evidencia a utilização do algoritmo. De seguida tratamos de fazer bruteforce com as seeds previamente calculadas, assim como 

```python
from Crypto.Cipher import AES

data = bytearray.fromhex('255044462d312e350a25d0d4c5d80a34')
ciphertext = bytearray.fromhex('d06bf9d0dab8e8ef880660d2af65aa82')
iv = bytearray.fromhex('09080706050403020100A2B2C2D2E2F2')

def bruteforce(allKeys):
    for line in allKeys:
        key = key.rstrip('\n')
        hexvalue = bytearray.fromhex(key)
        cipher = AES.new(key = hexvalue, mode=AES.MODE_CBC, iv = iv)
        guess = cipher.encrypt(data)
        if guess == ciphertext:
            print(f"The key is: {key}")
            return

def main():

    keys = []
    with open('keys.txt', 'r') as file:
        keys = file.readlines()
        file.close()

    bruteforce(keys)

main()
```



## Task 3: Measure the Entropy of Kernel

```bash
$ watch -n .1 cat /proc/sys/kernel/random/entropy_avail
```

## Task 4: Get Pseudo Random Numbers from /dev/random

```bash
$ cat /dev/random | hexdump
```

question

## Task 5: Get Random Numbers from /dev/urandom

TODO

```bash
$ cat /dev/urandom | hexdumps
```

# Author

G1:

- Alexandre Nunes (up202005358)
- Fábio Sá (up202007658)
- Inês Gaspar (up202007210)